/*
 * Copyright 2022 Holoinsight Project Authors. Licensed under Apache-2.0.
 */

package telegraf

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/influxdata/telegraf"
	"github.com/spf13/cast"
	containerhelpermodel "github.com/traas-stack/holoinsight-agent/cmd/containerhelper/model"
	"github.com/traas-stack/holoinsight-agent/pkg/accumulator"
	"github.com/traas-stack/holoinsight-agent/pkg/collectconfig"
	"github.com/traas-stack/holoinsight-agent/pkg/collecttask"
	"github.com/traas-stack/holoinsight-agent/pkg/collecttask/collecttaskcri"
	"github.com/traas-stack/holoinsight-agent/pkg/core"
	"github.com/traas-stack/holoinsight-agent/pkg/cri"
	"github.com/traas-stack/holoinsight-agent/pkg/ioc"
	"github.com/traas-stack/holoinsight-agent/pkg/logger"
	"github.com/traas-stack/holoinsight-agent/pkg/meta"
	"github.com/traas-stack/holoinsight-agent/pkg/pipeline/api"
	"github.com/traas-stack/holoinsight-agent/pkg/pipeline/integration/base"
	api2 "github.com/traas-stack/holoinsight-agent/pkg/plugin/api"
	telegraf2 "github.com/traas-stack/holoinsight-agent/pkg/telegraf"
	"github.com/traas-stack/holoinsight-agent/pkg/util"
	"go.uber.org/zap"
	"time"
)

type (
	Pipeline struct {
		interval time.Duration
		task     *collecttask.CollectTask
		input    interface{}
		output   *Output

		// commonTags will be attached to metrics generated by this pipeline
		commonTags       map[string]string
		cachedAttachTags map[string]string

		stopCh    chan struct{}
		stoppedCh chan struct{}

		transform base.Transform

		state *internalState
	}
	internalState struct {
		nextEmitTime time.Time
		timer        *util.AlignedTimer
	}
)

const (
	defaultExecTimeout = 5 * time.Second
)

func (p *Pipeline) SetupConsumer(st *api.SubTask) error {
	return nil
}

func (p *Pipeline) Update(f func(api.Pipeline)) {
	f(p)
}

func (p *Pipeline) View(f func(api.Pipeline)) {
	f(p)
}

func NewPipeline(executeRule *collectconfig.ExecuteRule, task *collecttask.CollectTask, input interface{}, output *Output, tags map[string]string, transform base.Transform) (*Pipeline, error) {
	intervalMills := 0
	offsetMills := 0
	// 现在只支持这个
	switch executeRule.Type {
	case "fixedRate":
		intervalMills = cast.ToInt(executeRule.FixedRate)
		offsetMills = executeRule.Offset
	}
	if intervalMills <= 0 {
		intervalMills = 60_000
	}
	interval := time.Duration(intervalMills) * time.Millisecond
	offset := time.Duration(offsetMills) * time.Millisecond

	timer, nextEmitTime := util.NewAlignedTimer(interval, offset, false, false)

	if transform.MetricPrefix == "" {
		if ip, ok := input.(api2.Input); ok {
			transform.MetricPrefix = ip.GetDefaultPrefix()
		}
	}

	return &Pipeline{
		interval:   interval,
		task:       task,
		input:      input,
		output:     output,
		commonTags: tags,
		stopCh:     make(chan struct{}),
		stoppedCh:  make(chan struct{}),
		state: &internalState{
			nextEmitTime: nextEmitTime,
			timer:        timer,
		},
		transform: transform,
	}, nil
}
func (p *Pipeline) Start() {
	go p.taskLoop()
}

func (p *Pipeline) Stop() {
	close(p.stopCh)
	<-p.stoppedCh
}

func (p *Pipeline) taskLoop() {
	// No need to defer stop timer

	timer := p.state.timer
	nextEmitTime := p.state.nextEmitTime

	defer func() {
		p.state.nextEmitTime = nextEmitTime
		p.state.timer = timer
		close(p.stoppedCh)
	}()

	for {
		select {
		case <-p.stopCh:
			return
		case <-timer.C:
			// TODO need an option to determine which metric time to use
			metricTime := nextEmitTime.Truncate(p.interval).Add(-p.interval)
			// metricTime := nextEmitTime.Truncate(p.interval)

			util.WithRecover(func() { p.collectOnce(metricTime) })
			nextEmitTime = timer.Next()
		}
	}
}

func (p *Pipeline) collectOnce(metricTime time.Time) {
	m := &accumulator.Memory{}
	begin := time.Now()
	err := p.collectOnce0(m)
	cost := time.Now().Sub(begin)

	var sendCost time.Duration
	if len(m.Metrics) > 0 {
		p.transformMetrics(metricTime, m)
		sendBegin := time.Now()
		p.output.Write(m.Metrics)
		sendCost = time.Now().Sub(sendBegin)
	}

	if logger.IsDebugEnabled() {
		for _, m := range m.Metrics {
			logger.Debugz("[pipeline] collect once debug", //
				zap.String("key", p.task.Key),               //
				zap.String("metric", m.Name),                //
				zap.Time("ts", time.UnixMilli(m.Timestamp)), //
				zap.Any("tags", m.Tags),                     //
				zap.Float64("value", m.Value),               //
			)
		}
	}

	logger.Infoz("[pipeline] collect once done", //
		zap.String("key", p.task.Key),          //
		zap.String("type", p.task.Config.Type), //
		zap.Int("metrics", len(m.Metrics)),     //
		zap.Duration("sendCost", sendCost),     //
		zap.Duration("cost", cost),             //
		zap.Error(err))
}

func (p *Pipeline) UpdateFrom(old api.Pipeline) {
	old2, ok := old.(*Pipeline)
	if !ok {
		return
	}
	if p.interval == old2.interval {
		p.state = old2.state
		if ext, ok := p.input.(api2.InputExt); ok {
			ext.UpdateFrom(old2.input)
		}
	}
}

// collectOnceWithExec collects datum by executing commands inside target container.
func (p *Pipeline) collectOnceWithExec(ine api2.InputExtNsEnter, m *accumulator.Memory) error {

	biz, err := collecttaskcri.GetTargetContainerE(ioc.Crii, p.task.Target)
	if err != nil {
		return err
	}

	state, actionType, reqBytes, timeout, err := ine.SerializeRequest()
	if err != nil {
		return err
	}

	if timeout <= 0 {
		timeout = defaultExecTimeout
	}

	// Add extra timeout
	ctx, cancel := context.WithTimeout(context.Background(), timeout+3*time.Second)
	defer cancel()

	execResult, err := ioc.Crii.Exec(ctx, biz, cri.ExecRequest{
		Cmd:   []string{core.HelperToolPath, "inputProxy", actionType},
		Input: bytes.NewBuffer(reqBytes),
	})

	if err != nil {
		stdout, stderr := execResult.SampleOutput()
		logger.Errorz("[pipeline] collect once by exec error", //
			zap.String("key", p.task.Key),            //
			zap.String("cmd", execResult.Cmd),        //
			zap.Int("exitcode", execResult.ExitCode), //
			zap.String("stdout", stdout),             //
			zap.String("stderr", stderr),             //
			zap.Error(err))                           //
	} else {
		bytesResp := containerhelpermodel.RespDataBytes{}
		err = json.Unmarshal(execResult.Stdout.Bytes(), &bytesResp)
		err = ine.ProcessResponse(state, bytesResp.Data, err, m)
	}

	return err
}

func (p *Pipeline) collectOnce0(m *accumulator.Memory) error {
	switch i := p.input.(type) {
	case telegraf.Input:
		return i.Gather(telegraf2.Adapt(m, "_"))
	case api2.Input:
		// In some envs, there is network isolation between holoinsight-agent pod and target pod.
		// In this case, plugins such as network detection can only be executed by entering the container through docker exec.
		// The first version of this code was written for runc, and we used the nsenter tool for this purpose.
		// But then we encountered rund, and nsenter's solution didn't work for it. At this point we can only use the standard docker.
		// Currently, some methods are still named with the 'nsenter' keyword, which will remove these couplings in the future.
		if ine, ok := p.input.(api2.InputExtNsEnter); ok && ine.NetworkMode() == api2.NetworkModePod {
			return p.collectOnceWithExec(ine, m)
		} else {
			return i.Collect(m)
		}
	default:
		return fmt.Errorf("unsupported input %v", p.input)
	}
}

// getTargetAttachTags returns tags associated with collect target
func (p *Pipeline) getTargetAttachTags() map[string]string {
	// This value is never changed when it is generated
	if len(p.cachedAttachTags) > 0 {
		return p.cachedAttachTags
	}

	var attachTags map[string]string

	switch p.task.Target.Type {
	case collecttask.TargetPod:
		namespace := p.task.Target.GetNamespace()
		podName := p.task.Target.GetPodName()
		if pod, err := ioc.Crii.GetPod(namespace, podName); err == nil {
			attachTags = meta.ExtractPodCommonTags(pod.Pod)
		}
	case collecttask.TargetLocalhost:
		attachTags = meta.ExtractSidecarTags()
	}
	p.cachedAttachTags = attachTags
	return attachTags
}

func (p *Pipeline) transformMetrics(metricTime time.Time, m *accumulator.Memory) {
	attachTags := p.getTargetAttachTags()

	ts := metricTime.UnixMilli()
	for i := range m.Metrics {
		m := m.Metrics[i]
		m.Timestamp = ts

		if m.Tags == nil {
			m.Tags = make(map[string]string)
		}
		for k, v := range p.commonTags {
			m.Tags[k] = v
		}
		for k, v := range attachTags {
			if v != "" {
				if _, ok := m.Tags[k]; !ok {
					m.Tags[k] = v
				}
			}
		}
	}

	if x := p.transform.MetricPrefix; x != "" {
		for _, metric := range m.Metrics {
			metric.Name = x + metric.Name
		}
	}
}
